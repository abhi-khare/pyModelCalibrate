"""_summary_
This file contains implementation of following uniform partition scheme:
1. Uniform mass partition
2. Uniform width partition
3. equal bin count partition
"""

def get_uniform_mass_partitions(probs: list, labels: list, partition_num: int, decreasing: bool = False) -> tuple:
    """
    Given a list of probabilities `probs` and a list of class labels `labels`, this function partition the probabilities
    into `partition_num` equal-mass partitions and return a tuple containing the sorted probabilities, sorted labels,
    and partition IDs for each probability. The probabilities and labels are sorted in increasing order by default,
    but this can be changed by setting the `decreasing` parameter to False.

    Parameters:
    - probs (list): A list of probabilities.
    - labels (list): A list of labels corresponding to the probabilities in `probs`.
    - partition_num (int): The number of equal-mass partitions to create.
    - decreasing (bool): A flag indicating whether to sort the probabilities and labels in decreasing order. Default is
                        False.

    Returns:
    - tuple: A tuple containing the sorted probabilities, sorted labels, and partition IDs for each probability.
    """

    samples = [(prob, label) for prob, label in zip(probs, labels)]

    sorted_samples = sorted(samples, key= lambda x: x[0], reverse=decreasing)

    partition_ids = [int(iter/partition_num)  for iter in range(len(probs))]

    sorted_probs, sorted_labels = zip(*sorted_samples)

    return sorted_probs, sorted_labels, partition_ids

def get_uniform_mass_partitions(probs: list, labels: list, partition_num: int, decreasing: bool = False) -> tuple:
    """

    :param probs: A list containing probability score generated by the uncalibrated model.
    :param labels: A list containing labels (+1, -1) or (0, 1)
    :param partition_num: total number of partitions that needs to be created on the sample sorted by the probs.
    :param decreasing: Order in which the sample should be sorted.
    :return: A tuple containing original prob, labels and partition_ids list.
    """

    samples = [(prob, label) for prob, label in zip(probs, labels)]

    sorted_samples = sorted(samples, key= lambda x: x[0], reverse=decreasing)

    partition_ids = [int(iter/partition_num)  for iter in range(len(probs))]

    sorted_probs, sorted_labels = zip(*sorted_samples)

    return sorted_probs, sorted_labels, partition_ids

def get_uniform_width_partitions(probs: list, labels: list, width: float) -> tuple:
    """

    :param probs:
    :param labels:
    :param width:
    :return:
    """

    samples = [(prob, label) for prob, label in zip(probs, labels)]

    sorted_samples = sorted(samples, key= lambda x: x[0])

    partition_ids = 
    
    sorted_probs, sorted_labels = zip(*sorted_samples)

    return sorted_probs, sorted_labels, partition_ids
        

